---
title: "C42 & HeLa Nm +1 Sites GO Analysis"
author: "Hannah Serio"
date: "2026-01-05"
output: html_document
---

```{r libraries, include=FALSE}

library(clusterProfiler)
library(org.Hs.eg.db)
library(ggplot2)
library(DOSE)
library(readxl)
library(openxlsx)
library(dplyr)

```

```
# function to read a section safely
read_section <- function(section_lines, file_path) {
  tryCatch({
    df <- read.table(text = section_lines, header = FALSE, stringsAsFactors = FALSE, sep = "\t")
    if (ncol(df) != 6) stop("Wrong number of columns")
    colnames(df) <- c("chr", "start", "gene", "strand", "sequence", "codon")
    df[] <- lapply(df, as.character)  # ensure all columns are character
    df$FileName <- basename(file_path)
    df
  }, error = function(e) {
    cat("Error reading section of file:", file_path, " - ", e$message, "\n")
    return(NULL)
  })
}

# Main file processing function
process_file <- function(file_path) {
  cat("Processing file:", file_path, "\n")
  
  # Read the file into a character vector
  lines <- readLines(file_path)
  
  # Find the indices of each Nm section marker
  index_m3 <- grep("\\-3 Nm", lines)
  index_m2 <- grep("\\-2 Nm", lines)
  index_m1 <- grep("\\-1 Nm", lines)
  index_1  <- grep("\\+1 Nm", lines)
  index_2  <- grep("\\+2 Nm", lines)
  index_3  <- grep("\\+3 Nm", lines)
  index_4  <- grep("\\+4 Nm", lines)
  
  # Ensure that all section markers are present
  all_indices <- list(index_m3, index_m2, index_m1, index_1, index_2, index_3, index_4)
  if (any(sapply(all_indices, length) == 0)) {
    cat("Missing one or more section headers in:", file_path, "\n")
    return(NULL)
  }
  
  # Helper to filter valid lines with exactly 6 fields
  filter_valid_lines <- function(lines) {
    valid_lines <- lines[sapply(strsplit(lines, "\t"), function(x) {
      if (length(x) != 6) {
        cat("Invalid line (expected 6 fields):", paste(x, collapse = "\t"), "\n")
        return(FALSE)
      }
      return(TRUE)
    })]
    return(valid_lines)
  }
  
  # Extract section lines
  get_section_lines <- function(start_idx, end_idx) {
    if (start_idx + 1 <= end_idx - 1) {
      return(filter_valid_lines(lines[(start_idx + 1):(end_idx - 1)]))
    } else {
      return(character())
    }
  }
  
  # Collect valid lines for each section
  section_lines <- list(
    m3 = get_section_lines(index_m3, index_m2),
    m2 = get_section_lines(index_m2, index_m1),
    m1 = get_section_lines(index_m1, index_1),
    p1 = get_section_lines(index_1, index_2),
    p2 = get_section_lines(index_2, index_3),
    p3 = get_section_lines(index_3, index_4),
    p4 = filter_valid_lines(lines[(index_4 + 1):length(lines)])
  )
  
  # Read each section into a dataframe using `read_section`
  section_dfs <- lapply(section_lines, function(section) {
    if (length(section) == 0) return(NULL)
    read_section(paste(section, collapse = "\n"), file_path)
  })
  
  names(section_dfs) <- c("-3Nm", "-2Nm", "-1Nm", "+1Nm", "+2Nm", "+3Nm", "+4Nm")
  
  return(section_dfs)
}

# ---- Specify individual file paths and assign cell line names ----
cognate_files <- list(
  HeLa = "./mlmHeLaCognates.bed",
  `C4-2` = "../../mlm/C42cells/C42cellsIndependentofHela/AllC42Cognates.bed"
)

# Process files and add cell line information
results_list <- lapply(names(cognate_files), function(cell_line) {
  file_path <- cognate_files[[cell_line]]
  result <- process_file(file_path)
  if (!is.null(result)) {
    # Add cell line name to each dataframe in the list
    result <- lapply(result, function(df) {
      if (!is.null(df)) {
        df$Cell_Line <- cell_line
      }
      return(df)
    })
  }
  return(result)
})
```

# Data Prep for GO Analysis - Nm[+1] Genes in 5'UTR
```{r dataprep, warning=FALSE}

### ignore excel file - use code above to generate sitesHeLa and C42
excel_file <- "5UTRNmPlus1Sites.xlsx" # table separated by sheets C-42, HeLa, and C4-2/HeLa overlap
sitesHeLa <- read_excel(excel_file, sheet = "HeLa", col_names = TRUE)
sitesC42 <- read_excel(excel_file, sheet = "C4-2", col_names = TRUE)
sitesC42HeLa <- read_excel(excel_file, sheet = "CommonSites_C4-2.HeLa", col_names = TRUE)

genesC42 <- unique(sitesC42$Gene)
genesHeLa <- unique(sitesHeLa$Gene)
genesC42.HeLa <- unique(sitesC42HeLa$Gene)

```

## Collective GO & KEGG analysis with dotplot visualization
```{r GOanalysisC42Collective, warning=FALSE, fig.width=8, fig.height=7, fig.path='GO_Results_CollectiveCategories/C42/', dev=c('png', 'pdf')}
# function to run GO analysis for all three ontologies, outputting the top 5 results with -log10(pvalue)
run_go_analysis_collective <- function(genes, 
                           orgdb = org.Hs.eg.db, 
                           keytype = "SYMBOL", 
                           plot_title = "GO Analysis") {
  
  # define the ontologies
  ontologies <- c("BP", "CC", "MF")
  
  # initialize empty list to store results
  all_results <- list()
  
  # run GO enrichment for each ontology
  for (ont in ontologies) {
    go_result <- enrichGO(gene          = genes, 
                          OrgDb         = orgdb, 
                          keyType       = keytype, 
                          ont           = ont, 
                          pAdjustMethod = "BH",
                          pvalueCutoff  = 1)
    
    # convert to data frame
    go_df <- as.data.frame(go_result)
    
    # if we have results, take top 5 and add ontology column
    if (nrow(go_df) > 0) {
      # calculate -log10(pvalue)
      go_df$logP <- -log10(go_df$pvalue)
      
      # add ontology column
      go_df$ontology <- ont
      
      # get top 5 results (already sorted by p-value)
      top_results <- head(go_df, 5)
      
      # store in list
      all_results[[ont]] <- top_results
    }
  }
  
  # combine all results into single data frame
  if (length(all_results) > 0) {
    combined_results <- do.call(rbind, all_results)
    rownames(combined_results) <- NULL
    return(combined_results)
  } else {
    # return empty data frame with expected columns if no results
    return(data.frame(
      ONTOLOGY = character(0),
      ID = character(0),
      Description = character(0),
      GeneRatio = character(0),
      BgRatio = character(0),
      pvalue = numeric(0),
      p.adjust = numeric(0),
      qvalue = numeric(0),
      geneID = character(0),
      Count = integer(0),
      logP = numeric(0),
      ontology = character(0)
    ))
  }
} 

# function to create dot plot from GO analysis results
plot_go_dotplot_collective <- function(go_results, 
                           title = "GO Enrichment Analysis",
                           x_axis = "pvalue",  # can be "pvalue", "p.adjust", or "logP"
                           max_char = 50) {  # maximum characters for category names
  
  # truncate long descriptions for better readability
  go_results$Description_short <- ifelse(
    nchar(go_results$Description) > max_char,
    paste0(substr(go_results$Description, 1, max_char), "..."),
    go_results$Description
  )
  
  # create factor for ordering (most significant first)
  if (x_axis == "logP") {
    go_results <- go_results[order(-go_results$logP), ]
  } else {
    go_results <- go_results[order(go_results[[x_axis]]), ]
  }
  
  go_results$Description_short <- factor(go_results$Description_short, 
                                        levels = rev(unique(go_results$Description_short)))
  
  # set up x-axis label and values
  if (x_axis == "pvalue") {
    x_label <- "P-value"
    x_values <- go_results$pvalue
  } else if (x_axis == "p.adjust") {
    x_label <- "Adjusted P-value"
    x_values <- go_results$p.adjust
  } else if (x_axis == "logP") {
    x_label <- "-log10(P-value)"
    x_values <- go_results$logP
  } else {
    stop("x_axis must be 'pvalue', 'p.adjust', or 'logP'")
  }
  
  # create color palette for ontologies
  ont_colors <- c("BP" = "#1f77b4",   # blue
                  "CC" = "#ff7f0e",   # orange  
                  "MF" = "#2ca02c")   # green
  
  # create the plot
  p <- ggplot(go_results, aes(x = x_values, 
                             y = Description_short, 
                             color = ontology, 
                             size = Count)) +
    geom_segment(aes(x = 0, xend = x_values, 
                     y = Description_short, yend = Description_short,
                     color = ontology), 
                 alpha = 0.6, size = 0.8) +
    geom_point() +
    scale_color_manual(values = ont_colors,
                      name = "Ontology",
                      labels = c("BP" = "Biological Process",
                                "CC" = "Cellular Component", 
                                "MF" = "Molecular Function")) +
    scale_size_continuous(name = "Gene Count",
                         range = c(2, 8)) +
    labs(title = title,
         x = x_label,
         y = NULL) +
    theme_minimal() +
    theme(axis.text.y = element_text(size = 10),
          axis.text.x = element_text(size = 10),
          plot.title = element_text(size = 14, hjust = 0.5),
          legend.title = element_text(size = 11),
          legend.text = element_text(size = 10),
          panel.grid.major.y = element_blank(),
          panel.grid.minor = element_blank(),
          panel.grid.major = element_blank(),
          axis.line = element_line(color = "black"),
          axis.ticks = element_line(color = "black"))
  
  # adjust x-axis formatting based on the values
  if (x_axis %in% c("pvalue", "p.adjust")) {
    if (max(x_values) < 0.01) {
      p <- p + scale_x_continuous(labels = scales::scientific_format())
    }
  }
  
  return(p)
}

resultsC42 <- run_go_analysis_collective(genes = genesC42)

resultsC42plot <- plot_go_dotplot_collective(go_result = resultsC42,
                                    title = "C4-2 Nm[+1] Genes",
                                    x_axis = "logP")
resultsC42plot

```

## Collective GO & KEGG HeLa
```{r GOanalysisHeLaCollective, warning=FALSE, fig.width=8, fig.height=7, fig.path='GO_Results_CollectiveCategories/HeLa/', dev=c('png', 'pdf')}

resultsHeLa <- run_go_analysis_collective(genes = genesHeLa)

resultsHeLaplot <- plot_go_dotplot_collective(go_result = resultsHeLa,
                                    title = "HeLa Nm[+1] Genes",
                                    x_axis = "logP")
resultsHeLaplot

```
